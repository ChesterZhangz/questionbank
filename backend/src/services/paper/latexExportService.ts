import fs from 'fs';
import path from 'path';
import { IPaper, IQuestionSnapshot } from '../../models/Paper';

export interface ExportOptions {
  includeAnswers?: boolean;
  withCover?: boolean;
  templateName?: string; // 预留多模板
  smartPageBreak?: boolean; // 智能分页选项
  enableZrefLabels?: boolean; // 为精准分页插入标签
}

export function buildLatexFromPaper(paper: IPaper, options: ExportOptions = {}): string {
  const templateName = options.templateName || 'practice';
  
  switch (templateName) {
    case 'test':
      return buildTestLatexFromPaper(paper, options);
    case 'answersheet':
      return buildAnswerSheetLatexFromPaper(paper, options);
    case 'practice':
    default:
      return buildPracticeLatexFromPaper(paper, options);
  }
}

// 智能分页试卷生成函数
export async function buildLatexFromPaperWithSmartPageBreak(
  paper: IPaper, 
  options: ExportOptions = {}
): Promise<{ success: boolean; latex?: string; pdfPath?: string; log?: string }> {
  try {
    // 如果启用了智能分页且是test模板
    if (options.smartPageBreak && options.templateName === 'test') {
      const { generatePaperWithSmartPageBreaks } = await import('./smartPageBreakService');
      const result = await generatePaperWithSmartPageBreaks(paper, options);
      
      if (result.success) {
        // 读取生成的LaTeX文件
        const fs = await import('fs');
        const path = await import('path');
        const latexPath = result.pdfPath?.replace('.pdf', '.tex');
        
        if (latexPath && fs.existsSync(latexPath)) {
          const latex = fs.readFileSync(latexPath, 'utf8');
          return {
            success: true,
            latex,
            pdfPath: result.pdfPath,
            log: result.log
          };
        }
      }
      
      return {
        success: false,
        log: result.log
      };
    } else {
      // 普通生成
      const latex = buildLatexFromPaper(paper, options);
      return {
        success: true,
        latex
      };
    }
  } catch (error) {
    return {
      success: false,
      log: error instanceof Error ? error.message : String(error)
    };
  }
}

// 原有的练习模板函数
function buildPracticeLatexFromPaper(paper: IPaper, options: ExportOptions = {}): string {
  const showAnswers = options.includeAnswers ? '\n\\showanswers\n' : '\n% answers hidden\n';
  const header = `\\documentclass[UTF8,10pt]{article}\n` +
    `\\usepackage{problemlab}\n` +
    `\\usepackage{needspace}\n` +
    `\\usepackage{etoolbox}\n` +
    (options.enableZrefLabels ? `\\usepackage{zref-abspage}\n` : '') +
    // 定义写入与占位命令（注意 @ 需要 makeatletter）
    (options.enableZrefLabels ? `\\makeatletter\\newcommand{\\mareateWriteRemain}[1]{\\immediate\\write\\@auxout{\\string\\mareate@remain{#1}{\\the\\dimexpr\\pagegoal-\\pagetotal\\relax}{\\the\\baselineskip}}}\\makeatother\n` : '') +
    (options.enableZrefLabels ? `\\makeatletter\\providecommand\\mareate@remain[3]{}\\makeatother\n` : '') +
    `% auto generated by Mareate Paper Service\n` +
    `${showAnswers}\n` +
    `\\title{\\textbf{${escapeTex(paper.name)}}}\n` +
    (paper.subject ? `\\author{${escapeTex(paper.subject)}}\n` : '') +
    `\\date{\\today}\n` +
    `\\begin{document}\n\\maketitle\n\\pagestyle{fancy}\n\\thispagestyle{fancy}\n\\renewcommand{\\headrulewidth}{0pt}\n`;

  let globalIndex = 0;
  const body = paper.sections.map(section => {
    const sectionTitle = escapeTex(section.title);
    const instruction = section.instruction ? escapeTex(section.instruction) : '';
    const items = section.items.map((it, idx) => {
      const snap = (it.snapshot || {}) as IQuestionSnapshot; // 发布后必有
      globalIndex += 1;
      const labelStart = options.enableZrefLabels ? `\\label{q-${globalIndex}-start}${'\n'}` : '';
      const badge = difficultyBadge(snap?.difficulty);
      const normalized = normalizeStemAndExtractOptions(snap?.stem ?? '');
      const stem = processLatexCommands(normalized.stem.trim(), 'practice');

      const finalOptions: string[] = Array.isArray(snap?.options) && snap.options.length > 0
        ? snap.options
        : (normalized.options.length > 0 ? normalized.options : []);

      const optionsBlock = finalOptions.length > 0
        ? buildTasksBlock(finalOptions, 'practice')
        : '';
      // 处理题干和解答的分离
      let mainStem = stem;
      let subproblemContent = '';
      
      // 如果题干包含 \subp，需要分离题干和子问题
      if (stem.includes('\\subp')) {
        const parts = stem.split('\\subp');
        if (parts.length > 1) {
          mainStem = parts[0].trim(); // 题干部分
          subproblemContent = '\\subp' + parts.slice(1).join('\\subp'); // 子问题部分
        }
      } else if (stem.includes('\\item')) {
        // 如果已经处理过了，找到第一个 \item 的位置
        const itemIndex = stem.indexOf('\\item');
        if (itemIndex > 0) {
          mainStem = stem.substring(0, itemIndex).trim(); // 题干部分
          subproblemContent = stem.substring(itemIndex); // 子问题部分
        }
      }
      
      // 处理解答部分，移除"解答："前缀；Practice 模板：不再生成答题区（answerarea）
      const analysisText = processLatexCommands(collapseEscapedBackslashes((snap?.analysis ?? '').replace(/\\n\s*/g, '\n')), 'practice');
      let analysis = '';
      if (analysisText && analysisText.trim().length > 0 && options.includeAnswers) {
        // 显示答案时使用 answer 环境，移除"解答："前缀
        const cleanAnalysis = analysisText.replace(/^解答：\s*/, '').replace(/^解答\s*/, '').replace(/^解答：\s*/, '');
        const labelAns = options.enableZrefLabels ? `\\label{q-${globalIndex}-ans}\n` : '';
        analysis = `${labelAns}\\begin{answer}\n${cleanAnalysis}\n\\end{answer}`;
      }
      
      // 每道题作为一个 \\item；徽标可附加来源标签
      const badgeWithSrc = appendSourceToBadge(badge, snap?.source);
      
      // 单页适配：如总量超过一页，优先在题目前换页并压缩答题区至单页容量
       const nonAnswerEstimated = estimatePracticeItemLines({
        stem,
        mainStem,
        subproblemContent,
        optionsCount: finalOptions.length,
        isSolution: snap?.type === 'solution',
        includeAnswers: Boolean(options.includeAnswers),
        analysisText,
        analysisAreaLines: 0
      });

      const pageCap = PRACTICE_MAX_LINES_PER_PAGE;
      let preamble = '';

      // 智能分页：估算所需行数并在题目前插入 Needspace，避免题目与答题区域跨页
      const estimatedLines = estimatePracticeItemLines({
        stem,
        mainStem,
        subproblemContent,
        optionsCount: finalOptions.length,
        isSolution: snap?.type === 'solution',
        includeAnswers: Boolean(options.includeAnswers),
        analysisText,
        analysisAreaLines: 0
      });
      // 使用 Needspace 确保题目和答题区不撕裂；为“答题区顶到页首”留余：若上一元素不是空行，强制加 \par，Needspace 兜底
      const needspace = `\\par\n\\Needspace{${estimatedLines}\\baselineskip}`;

      // 如果有子问题，先显示题干，然后是子问题
      if (subproblemContent) {
        return `${preamble}${needspace}\n${labelStart}\\item ${badgeWithSrc} ${mainStem}\n${subproblemContent}\n${optionsBlock}\n${analysis}`;
      } else {
        return `${preamble}${needspace}\n${labelStart}\\item ${badgeWithSrc} ${stem}\n${optionsBlock}\n${analysis}`;
      }
    }).join('\n\n');
    return `\\begin{problem}[${sectionTitle}]\n${items}\n\\end{problem}`;
  }).join('\n\n');

  const tail = `\\end{document}\n`;
  return [header, body, tail].join('\n');
}

// 根据选项内容长度智能选择 tasks 列数：长→(1)，中→(2)，短→(4)
function buildTasksBlock(options: string[], templateName: 'practice' | 'test'): string {
  const processed = options.map(o => processLatexCommands(collapseEscapedBackslashes(o), templateName));
  // 粗略长度估计：去命令后按可见字符计数
  const visibleLen = (s: string) => s
    .replace(/\\[a-zA-Z@]+\*?(\[[^\]]*\])?(\{[^}]*\})?/g, '') // 去掉简单命令
    .replace(/\$|\{|\}|\^|\_|\%|\&|\#/g, '')
    .replace(/\s+/g, ' ')
    .trim().length;
  const lengths = processed.map(visibleLen);
  const maxLen = Math.max(0, ...lengths);

  // 阈值可按字号/版心微调：<28 视为短；<60 视为中；否则长
  const cols = maxLen < 28 ? 4 : (maxLen < 60 ? 2 : 1);
  const header = `\\begin{tasks}(${cols})`;
  const body = processed.map(o => `\\task ${o}`).join('\n');
  const footer = '\\end{tasks}';
  return [header, body, footer].join('\n');
}

// 新的测试模板函数
function buildTestLatexFromPaper(paper: IPaper, options: ExportOptions = {}): string {
  // 读取测试模板（兼容开发 src 与生产 dist 路径）
  const templatePath = resolveTemplatePath('testlab.tex');
  let template = fs.readFileSync(templatePath, 'utf8');
  
  // 计算题目统计信息
  const stats = calculatePaperStats(paper);
  
  // 生成动态试卷内容
  const dynamicSections = generateDynamicSections(paper, options);
  
  // 生成自定义考生注意信息
  const customInstructions = generateCustomInstructions(paper, stats);
  
  // 替换模板占位符
  template = template.replace(/%%PAPER_TITLE%%/g, escapeTex(paper.name));
  template = template.replace(/%%PAPER_SUBJECT%%/g, escapeTex(paper.subject || '数学'));
  template = template.replace(/%%EXAM_DURATION%%/g, (paper.examInstructions?.examDuration || 120).toString());
  template = template.replace(/%%TOTAL_QUESTIONS%%/g, stats.totalQuestions.toString());
  template = template.replace(/%%TOTAL_SCORE%%/g, stats.totalScore.toString());
  template = template.replace(/%%CUSTOM_INSTRUCTIONS%%/g, customInstructions);
  template = template.replace(/%%DYNAMIC_SECTIONS%%/g, dynamicSections);
  
  return template;
}

// 新的答题卡模板函数
function buildAnswerSheetLatexFromPaper(paper: IPaper, options: ExportOptions = {}): string {
  // 读取答题卡模板（兼容开发 src 与生产 dist 路径）
  const templatePath = resolveTemplatePath('answersheet.tex');
  let template = fs.readFileSync(templatePath, 'utf8');
  
  // 计算题目统计信息
  const stats = calculatePaperStats(paper);
  
  // 生成答题卡内容
  const answerSheetContent = generateAnswerSheetContent(paper, stats);
  
  // 替换模板占位符
  template = template.replace(/%%PAPER_TITLE%%/g, escapeTex(paper.name));
  template = template.replace(/%%PAPER_SUBJECT%%/g, escapeTex(paper.subject || '数学'));
  template = template.replace(/%%FILL_COUNT%%/g, stats.fillCount.toString());
  template = template.replace(/%%FILL_SCORE%%/g, stats.fillScore.toString());
  template = template.replace(/%%CHOICE_COUNT%%/g, stats.choiceCount.toString());
  template = template.replace(/%%CHOICE_SCORE%%/g, stats.choiceScore.toString());
  template = template.replace(/%%SOLUTION_COUNT%%/g, stats.solutionCount.toString());
  template = template.replace(/%%SOLUTION_SCORE%%/g, stats.solutionScore.toString());
  template = template.replace(/%%ANSWER_SHEET_CONTENT%%/g, answerSheetContent);
  
  return template;
}

// 计算试卷统计信息
function calculatePaperStats(paper: IPaper) {
  let fillCount = 0, choiceCount = 0, multipleChoiceCount = 0, solutionCount = 0;
  let fillScore = 0, choiceScore = 0, multipleChoiceScore = 0, solutionScore = 0;
  let currentQuestionNumber = 1;
  
  const stats = {
    fillStart: 0, fillEnd: 0,
    choiceStart: 0, choiceEnd: 0,
    multipleChoiceStart: 0, multipleChoiceEnd: 0,
    solutionStart: 0, solutionEnd: 0,
    fillCount: 0, choiceCount: 0, multipleChoiceCount: 0, solutionCount: 0,
    fillScore: 0, choiceScore: 0, multipleChoiceScore: 0, solutionScore: 0,
    totalQuestions: 0, totalScore: 0,
    questionOrder: [] as Array<{type: string, number: number, score: number}>
  };
  
  paper.sections.forEach(section => {
    section.items.forEach(item => {
      const snap = item.snapshot as IQuestionSnapshot;
      const type = snap?.type || 'fill';
      const score = item.score || 5;
      
      // 记录题目顺序
      stats.questionOrder.push({type, number: currentQuestionNumber, score});
      
      if (type === 'fill') {
        if (fillCount === 0) stats.fillStart = currentQuestionNumber;
        fillCount++;
        fillScore += score;
        stats.fillEnd = currentQuestionNumber;
      } else if (type === 'choice') {
        if (choiceCount === 0) stats.choiceStart = currentQuestionNumber;
        choiceCount++;
        choiceScore += score;
        stats.choiceEnd = currentQuestionNumber;
      } else if (type === 'multiple-choice') {
        if (multipleChoiceCount === 0) stats.multipleChoiceStart = currentQuestionNumber;
        multipleChoiceCount++;
        multipleChoiceScore += score;
        stats.multipleChoiceEnd = currentQuestionNumber;
      } else if (type === 'solution') {
        if (solutionCount === 0) stats.solutionStart = currentQuestionNumber;
        solutionCount++;
        solutionScore += score;
        stats.solutionEnd = currentQuestionNumber;
      }
      
      currentQuestionNumber++;
    });
  });
  
  stats.fillCount = fillCount;
  stats.choiceCount = choiceCount;
  stats.multipleChoiceCount = multipleChoiceCount;
  stats.solutionCount = solutionCount;
  stats.fillScore = fillScore;
  stats.choiceScore = choiceScore;
  stats.multipleChoiceScore = multipleChoiceScore;
  stats.solutionScore = solutionScore;
  stats.totalQuestions = currentQuestionNumber - 1;
  stats.totalScore = fillScore + choiceScore + multipleChoiceScore + solutionScore;
  
  return stats;
}

// 生成填空题部分
function generateFillSection(paper: IPaper, options: ExportOptions): string {
  const fillQuestions = getAllQuestionsByType(paper, 'fill');
  if (fillQuestions.length === 0) return '';
  
  const items = fillQuestions.map((item, idx) => {
    const snap = item.snapshot as IQuestionSnapshot;
    const normalized = normalizeStemAndExtractOptions(snap?.stem ?? '');
    const stem = processLatexCommands(normalized.stem.trim(), 'test');
    return `    \\item ${stem} \\underlines.`;
  }).join('\n');
  
  return `\\textbf{一、填空题(本大题共 ${fillQuestions.length} 题，每题 5 分，满分 ${fillQuestions.length * 5} 分)}

\\qquad \\textbf{考生应在答题卷的相应位置直接填写结果.}

\\begin{enumerate}[leftmargin=55pt]
${items}
\\end{enumerate}

\\vspace{1cm}`;
}

// 生成选择题部分
function generateChoiceSection(paper: IPaper, options: ExportOptions): string {
  const choiceQuestions = getAllQuestionsByType(paper, 'choice');
  if (choiceQuestions.length === 0) return '';
  
  const items = choiceQuestions.map((item, idx) => {
    const snap = item.snapshot as IQuestionSnapshot;
    const normalized = normalizeStemAndExtractOptions(snap?.stem ?? '');
    const stem = processLatexCommands(normalized.stem.trim(), 'test');
    
    const finalOptions: string[] = Array.isArray(snap?.options) && snap.options.length > 0
      ? snap.options
      : (normalized.options.length > 0 ? normalized.options : []);
    
    const optionsBlock = finalOptions.length > 0
      ? buildTasksBlock(finalOptions, 'test')
      : '';
    
    return `    \\item ${stem} \\dotfill (\\qquad \\qquad)
${optionsBlock}`;
  }).join('\n\n');
  
  return `\\textbf{二、选择题(本大题共 ${choiceQuestions.length} 题，每题 5 分，满分 ${choiceQuestions.length * 5} 分)}

\\qquad \\textbf{每题有且只有一个正确选项，考生应在答题卷的相应位置，填写正确选项的字母代号.}

\\begin{enumerate}[leftmargin=55pt,start=${getQuestionStartNumber(paper, 'choice')}]
${items}
\\end{enumerate}

\\vspace{0.5cm}`;
}

// 生成多选题部分
function generateMultipleChoiceSection(paper: IPaper, options: ExportOptions): string {
  const multipleChoiceQuestions = getAllQuestionsByType(paper, 'multiple-choice');
  if (multipleChoiceQuestions.length === 0) return '';
  
  const items = multipleChoiceQuestions.map((item, idx) => {
    const snap = item.snapshot as IQuestionSnapshot;
    const normalized = normalizeStemAndExtractOptions(snap?.stem ?? '');
    const stem = processLatexCommands(normalized.stem.trim(), 'test');
    
    const finalOptions: string[] = Array.isArray(snap?.options) && snap.options.length > 0
      ? snap.options
      : (normalized.options.length > 0 ? normalized.options : []);
    
    const optionsBlock = finalOptions.length > 0
      ? buildTasksBlock(finalOptions, 'test')
      : '';
    
    return `    \\item ${stem} \\dotfill (\\qquad \\qquad)
${optionsBlock}`;
  }).join('\n\n');
  
  return `\\textbf{三、多选题(本大题共 ${multipleChoiceQuestions.length} 题，每题 5 分，满分 ${multipleChoiceQuestions.length * 5} 分)}

\\qquad \\textbf{每题可能有多个正确选项，考生应在答题卷的相应位置，填写所有正确选项的字母代号.}

\\begin{enumerate}[leftmargin=55pt,start=${getQuestionStartNumber(paper, 'multiple-choice')}]
${items}
\\end{enumerate}

\\vspace{0.5cm}`;
}

// 生成动态试卷内容
function generateDynamicSections(paper: IPaper, options: ExportOptions): string {
  const sections: string[] = [];
  let currentQuestionNumber = 1;
  
  paper.sections.forEach((section, sectionIndex) => {
    const sectionTitle = escapeTex(section.title);
    const instruction = section.instruction ? escapeTex(section.instruction) : '';
    
    // 按题目类型分组
    const questionsByType = new Map<string, any[]>();
    
    section.items.forEach(item => {
      const snap = item.snapshot as IQuestionSnapshot;
      const type = snap?.type || 'fill';
      if (!questionsByType.has(type)) {
        questionsByType.set(type, []);
      }
      questionsByType.get(type)!.push(item);
    });
    
    // 为每种题型生成内容
    questionsByType.forEach((questions, type) => {
      const totalScore = questions.reduce((sum, item) => sum + (item.score || 5), 0);
      const avgScore = Math.round(totalScore / questions.length);
      
      let sectionContent = '';
      let sectionTitle = '';
      let instruction = '';
      
      switch (type) {
        case 'fill':
          sectionTitle = `\\textbf{${getChineseNumber(sectionIndex + 1)}、填空题(本大题共 ${questions.length} 题，每题 ${avgScore} 分，满分 ${totalScore} 分)}`;
          instruction = '\\qquad \\textbf{考生应在答题卷的相应位置直接填写结果.}';
          sectionContent = questions.map((item, idx) => {
            const snap = item.snapshot as IQuestionSnapshot;
            const normalized = normalizeStemAndExtractOptions(snap?.stem ?? '');
            const stem = processLatexCommands(normalized.stem.trim(), 'test');
            return `    \\item ${stem} \\underlines.`;
          }).join('\n');
          break;
          
        case 'choice':
          sectionTitle = `\\textbf{${getChineseNumber(sectionIndex + 1)}、选择题(本大题共 ${questions.length} 题，每题 ${avgScore} 分，满分 ${totalScore} 分)}`;
          instruction = '\\qquad \\textbf{每题有且只有一个正确选项，考生应在答题卷的相应位置，填写正确选项的字母代号.}';
          sectionContent = questions.map((item, idx) => {
            const snap = item.snapshot as IQuestionSnapshot;
            const normalized = normalizeStemAndExtractOptions(snap?.stem ?? '');
            const stem = processLatexCommands(normalized.stem.trim(), 'test');
            
            const finalOptions: string[] = Array.isArray(snap?.options) && snap.options.length > 0
              ? snap.options
              : (normalized.options.length > 0 ? normalized.options : []);
            
            const optionsBlock = finalOptions.length > 0
              ? buildTasksBlock(finalOptions, 'test')
              : '';
            
            return `    \\item ${stem} \\dotfill (\\qquad \\qquad)\n${optionsBlock}`;
          }).join('\n\n');
          break;
          
        case 'multiple-choice':
          sectionTitle = `\\textbf{${getChineseNumber(sectionIndex + 1)}、多选题(本大题共 ${questions.length} 题，每题 ${avgScore} 分，满分 ${totalScore} 分)}`;
          instruction = '\\qquad \\textbf{每题有多个正确选项，考生应在答题卷的相应位置，填写所有正确选项的字母代号.}';
          sectionContent = questions.map((item, idx) => {
            const snap = item.snapshot as IQuestionSnapshot;
            const normalized = normalizeStemAndExtractOptions(snap?.stem ?? '');
            const stem = processLatexCommands(normalized.stem.trim(), 'test');
            
            const finalOptions: string[] = Array.isArray(snap?.options) && snap.options.length > 0
              ? snap.options
              : (normalized.options.length > 0 ? normalized.options : []);
            
            const optionsBlock = finalOptions.length > 0
              ? buildTasksBlock(finalOptions, 'test')
              : '';
            
            return `    \\item ${stem} \\dotfill (\\qquad \\qquad)\n${optionsBlock}`;
          }).join('\n\n');
          break;
          
        case 'solution':
          sectionTitle = `\\textbf{${getChineseNumber(sectionIndex + 1)}、解答题(本大题共 ${questions.length} 题，满分 ${totalScore} 分)}`;
          sectionContent = questions.map((item, idx) => {
            const snap = item.snapshot as IQuestionSnapshot;
            const normalized = normalizeStemAndExtractOptions(snap?.stem ?? '');
            const stem = processLatexCommands(normalized.stem.trim(), 'test');
            const score = item.score || 10;
            
            // Test模板不显示解析部分
            let analysis = '';
            if (options.includeAnswers && snap?.analysis) {
              const analysisText = processLatexCommands(collapseEscapedBackslashes((snap.analysis).replace(/\\n\s*/g, '\n')), 'test');
              // 修复：正确处理analysis中的subp转换为enumerate结构
              const subpItems = analysisText.split('\\subp').filter(item => item.trim());
              if (subpItems.length > 0) {
                analysis = `\\begin{enumerate}[start=1,label=(\\arabic*)]
${subpItems.map(item => `    \\item ${item.trim()}`).join('\n')}
\\end{enumerate}`;
              }
            }
            
            // 处理题干中的小问，确保它们包装在enumerate环境中
            let processedStem = stem;
            let subQuestionScores = '';
            
            // 计算小问分值
            const originalStem = snap?.stem ?? '';
            if (originalStem.includes('\\subp')) {
              // 计算小问数量
              const subpCount = (originalStem.match(/\\subp/g) || []).length;
              
              if (subpCount > 1) {
                const baseScore = Math.floor(score / subpCount);
                const remainder = score % subpCount;
                const subScores = [];
                
                for (let i = 0; i < subpCount; i++) {
                  const subScore = baseScore + (i < remainder ? 1 : 0);
                  
                  // 检查这个小问是否包含小小问
                  const subpRegex = /\\subp([\s\S]*?)(?=\\subp|$)/g;
                  const subpMatches = [];
                  let match;
                  while ((match = subpRegex.exec(originalStem)) !== null) {
                    subpMatches.push(match);
                  }
                  
                  if (subpMatches[i]) {
                    const subpContent = subpMatches[i][1];
                    const subsubpCount = (subpContent.match(/\\subsubp/g) || []).length;
                    
                    if (subsubpCount > 0) {
                      // 有小小问，计算小小问分值
                      const subsubpBaseScore = Math.floor(subScore / subsubpCount);
                      const subsubpRemainder = subScore % subsubpCount;
                      
                      const subsubpScores = [];
                      for (let j = 0; j < subsubpCount; j++) {
                        const subsubpScore = subsubpBaseScore + (j < subsubpRemainder ? 1 : 0);
                        subsubpScores.push(`\\textcircled{${j + 1}}满分${subsubpScore}分`);
                      }
                      
                      subScores.push(`第(${i + 1})小题满分${subScore}分，其中 ${subsubpScores.join('，')}`);
                    } else {
                      // 没有小小问
                      subScores.push(`第(${i + 1})小题满分${subScore}分`);
                    }
                  } else {
                    subScores.push(`第(${i + 1})小题满分${subScore}分`);
                  }
                }
                
                subQuestionScores = `，${subScores.join('，')}`;
              }
              
              // 处理题干结构：将\subp转换为\item并包装在enumerate环境中
              if (stem.includes('\\item')) {
                // 使用正则表达式分离题干和小问
                const parts = stem.split('\\item');
                if (parts.length > 1) {
                  const questionText = parts[0].trim(); // 题干内容
                  const subQuestions = parts.slice(1).map(part => part.trim()).filter(part => part.length > 0);
                  
                  if (subQuestions.length > 0) {
                    const subQuestionItems = subQuestions.map(q => `    \\item ${q}`).join('\n');
                    processedStem = `${questionText}\n\n    \\begin{enumerate}[start=1,label=(\\arabic*)]\n${subQuestionItems}\n    \\end{enumerate}`;
                  }
                }
              }
            }
            
            return `    \\item \\textbf{（本大题满分$${score}$分${subQuestionScores}）} 

    ${processedStem}
    
    ${analysis}`;
          }).join('\n\n');
          break;
      }
      
      if (sectionContent) {
        const startNumber = currentQuestionNumber;
        const endNumber = currentQuestionNumber + questions.length - 1;
        
        sections.push(`${sectionTitle}

${instruction}

\\begin{enumerate}[leftmargin=55pt,start=${startNumber}]
${sectionContent}
\\end{enumerate}

\\vspace{0.5cm}

`);
        
        currentQuestionNumber += questions.length;
      }
    });
  });
  
  return sections.join('\n');
}

// 获取中文数字
function getChineseNumber(num: number): string {
  const chineseNumbers = ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十'];
  if (num <= 10) {
    return chineseNumbers[num - 1];
  } else if (num <= 99) {
    if (num % 10 === 0) {
      return chineseNumbers[Math.floor(num / 10) - 1] + '十';
    } else {
      return chineseNumbers[Math.floor(num / 10) - 1] + '十' + chineseNumbers[num % 10 - 1];
    }
  }
  return num.toString();
}

// 根据题目位置获取题目编号
function getQuestionNumberByPosition(paper: IPaper, stats: any, type: string, localIndex: number): number {
  let currentNumber = 1;
  let typeCount = 0;
  
  for (const section of paper.sections) {
    for (const item of section.items) {
      const snap = item.snapshot as IQuestionSnapshot;
      const itemType = snap?.type || 'fill';
      
      if (itemType === type) {
        if (typeCount === localIndex) {
          return currentNumber;
        }
        typeCount++;
      }
      
      currentNumber++;
    }
  }
  
  return localIndex + 1; // 默认返回
}

// 生成解答题部分
function generateSolutionSection(paper: IPaper, options: ExportOptions): string {
  const solutionQuestions = getAllQuestionsByType(paper, 'solution');
  if (solutionQuestions.length === 0) return '';
  
  const items = solutionQuestions.map((item, idx) => {
    const snap = item.snapshot as IQuestionSnapshot;
    const normalized = normalizeStemAndExtractOptions(snap?.stem ?? '');
    const stem = processLatexCommands(normalized.stem.trim(), 'test');
    const score = item.score || 10;
    
    // Test模板不显示解析部分
    let analysis = '';
    if (options.includeAnswers && snap?.analysis) {
      const analysisText = processLatexCommands(collapseEscapedBackslashes((snap.analysis).replace(/\\n\s*/g, '\n')), 'test');
      // 修复：正确处理analysis中的subp转换为enumerate结构
      const subpItems = analysisText.split('\\subp').filter(item => item.trim());
      if (subpItems.length > 0) {
        analysis = `\\begin{enumerate}[start=1,label=(\\arabic*)]
${subpItems.map(item => `    \\item ${item.trim()}`).join('\n')}
\\end{enumerate}`;
      }
    }
    
    // 处理题干中的小问，确保它们包装在enumerate环境中
    let processedStem = stem;
    let subQuestionScores = '';
    
    // 计算小问分值
    const originalStem = snap?.stem ?? '';
    if (originalStem.includes('\\subp')) {
      // 计算小问数量
      const subpCount = (originalStem.match(/\\subp/g) || []).length;
      
      if (subpCount > 1) {
        const baseScore = Math.floor(score / subpCount);
        const remainder = score % subpCount;
        const subScores = [];
        
        for (let i = 0; i < subpCount; i++) {
          const subScore = baseScore + (i < remainder ? 1 : 0);
          
          // 检查这个小问是否包含小小问
          const subpRegex = /\\subp([\s\S]*?)(?=\\subp|$)/g;
          const subpMatches = [];
          let match;
          while ((match = subpRegex.exec(originalStem)) !== null) {
            subpMatches.push(match);
          }
          
          if (subpMatches[i]) {
            const subpContent = subpMatches[i][1];
            const subsubpCount = (subpContent.match(/\\subsubp/g) || []).length;
            
            if (subsubpCount > 0) {
              // 有小小问，计算小小问分值
              const subsubpBaseScore = Math.floor(subScore / subsubpCount);
              const subsubpRemainder = subScore % subsubpCount;
              
              const subsubpScores = [];
              for (let j = 0; j < subsubpCount; j++) {
                const subsubpScore = subsubpBaseScore + (j < subsubpRemainder ? 1 : 0);
                subsubpScores.push(`\\textcircled{${j + 1}}满分${subsubpScore}分`);
              }
              
              subScores.push(`第(${i + 1})小题满分${subScore}分，其中 ${subsubpScores.join('，')}`);
            } else {
              // 没有小小问
              subScores.push(`第(${i + 1})小题满分${subScore}分`);
            }
          } else {
            subScores.push(`第(${i + 1})小题满分${subScore}分`);
          }
        }
        
        subQuestionScores = `，${subScores.join('，')}`;
      }
      
      // 处理题干结构：将\subp转换为\item并包装在enumerate环境中
      if (stem.includes('\\item')) {
        // 使用正则表达式分离题干和小问
        const parts = stem.split('\\item');
        if (parts.length > 1) {
          const questionText = parts[0].trim(); // 题干内容
          const subQuestions = parts.slice(1).map(part => part.trim()).filter(part => part.length > 0);
          
          if (subQuestions.length > 0) {
            const subQuestionItems = subQuestions.map(q => `    \\item ${q}`).join('\n');
            processedStem = `${questionText}\n\n    \\begin{enumerate}[start=1,label=(\\arabic*)]\n${subQuestionItems}\n    \\end{enumerate}`;
          }
        }
      }
    }
    
    return `    \\item \\textbf{（本大题满分$${score}$分${subQuestionScores}）} 

    ${processedStem}
    
    ${analysis}`;
  }).join('\n\n');
  
  const sectionNumber = getSectionNumber(paper, 'solution');
  const sectionTitle = sectionNumber === 3 ? '三' : (sectionNumber === 4 ? '四' : '五');
  
  return `\\textbf{${sectionTitle}、解答题(本大题共 ${solutionQuestions.length} 题，满分 ${solutionQuestions.reduce((sum, item) => sum + (item.score || 10), 0)} 分)} 

\\begin{enumerate}[leftmargin=55pt,start=${getQuestionStartNumber(paper, 'solution')}]
${items}
\\end{enumerate}`;
}

// 生成自定义考生注意信息
function generateCustomInstructions(paper: IPaper, stats: any): string {
  const instructions = paper.examInstructions || {};
  let customInstructions = '';
  let itemNumber = 3; // 从第3项开始，因为前两项是固定的
  
  // 添加答案上传时间
  if (instructions.answerUploadTime) {
    customInstructions += `        \\item 请将答案写在答题纸上，请保证答题纸整洁，并在考试结束后${instructions.answerUploadTime}分钟内上传答案；\n\n`;
    itemNumber++;
  } else {
    customInstructions += `        \\item 请将答案写在答题纸上，请保证答题纸整洁，并在考试结束后二十分钟内上传答案；\n\n`;
    itemNumber++;
  }
  
  // 添加电子产品限制
  customInstructions += `		\\item 测试期间严禁查看除计算器以外的电子产品，除试卷、答题纸以外的纸质产品（包括但不限于《数学基础课程讲义》纸质版、已完成的MMS 课程作业纸等任何具有数学标志的物品）. \n\n`;
  itemNumber++;
  
  // 添加计算器使用政策
  if (instructions.calculatorPolicy) {
    customInstructions += `        \\item ${instructions.calculatorPolicy}\n\n`;
  } else {
    customInstructions += `        \\item 测试期间只允许使用数学计算器进行答题（卡西欧计算器），也能够使用 \\href{https://www.wolframalpha.com/}{Wolframalpha} 进行计算，禁止使用计算器解方程等，除下方声明题目外，其余题目均保留具体数值（声明题目按照要求作答）；\n\n`;
  }
  itemNumber++;
  
  // 自动生成知识点信息
  const knowledgePoints = extractKnowledgePoints(paper);
  if (knowledgePoints.length > 0) {
    customInstructions += `        \\item 本试卷测试包含以下知识点：${knowledgePoints.join('、')}；\n\n`;
    itemNumber++;
  }
  
  // 添加答案格式要求
  if (instructions.answerFormat) {
    customInstructions += `        \\item ${instructions.answerFormat}\n\n`;
  } else {
    customInstructions += `        \\item 在没有明确说明时，$S_{n}$ 代表某数列的前$n$项和；任何含字母系数出现的数均为实数；$\\sum$ 不标注任何上界或下界单独出现时表示轮换求和，与 $\\displaystyle \\sum_{cyc}$ 等价；$\\prod$ 不标注任何上界或下界单独出现时表示轮换求积，与$\\displaystyle \\prod_{cyc}$等价；数学粗体字母 $\\mathbf{i}$ 代表虚数单位，即$\\mathbf{i}^2 = -1$；$\\pi$ 代表圆周率\n\n`;
  }
  itemNumber++;
  
  // 添加特殊注意事项
  if (instructions.specialNotes && instructions.specialNotes.length > 0) {
    for (const note of instructions.specialNotes) {
      customInstructions += `        \\item ${note}\n\n`;
      itemNumber++;
    }
  } else {
    customInstructions += `        \\item 答题时，题目未有明确说明时以精确值的形式呈现最终答案，如$\\sqrt{3}$等形式. \n\n`;
    customInstructions += `        \\item 解答题中所有最终答案用方框圈出来，以便批改. \n\n`;
  }
  
  return customInstructions;
}

// 提取知识点
function extractKnowledgePoints(paper: IPaper): string[] {
  const knowledgePoints = new Set<string>();
  
  // 从所有题目的标签中提取知识点
  for (const section of paper.sections) {
    for (const item of section.items) {
      if (item.snapshot?.tags) {
        for (const tag of item.snapshot.tags) {
          // 过滤掉一些非知识点的标签
          if (!['简单', '中等', '困难', '基础', '提高', '竞赛'].includes(tag)) {
            knowledgePoints.add(tag);
          }
        }
      }
    }
  }
  
  return Array.from(knowledgePoints).sort();
}

// 生成答题卡内容
function generateAnswerSheetContent(paper: IPaper, stats: any): string {
  let content = '';
  
  // 添加考号填写区域
  content += `\\draw[BrickRed,line width=1pt]
		([shift={(0,-1.4)}]A1)rectangle ++({\\lk},-5.5)
		([shift={({\\lk/2},-1.4)}]A1)--++(0,-5.5);
	\\draw
		([shift={({\\lk/4},-1.4)}]A1)node[below]{准考证号};
	\\draw[BrickRed]
		(A0) rectangle (C0);
	\\foreach \\x in {1,2,...,\\khws}
		\\draw[BrickRed]([shift={({(\\x-1)*\\gzk},0)}]A0)--++(0,-0.7);
	\\foreach \\x in {1,2,...,\\khws}
	\\foreach \\y in {0,1,...,9}
		\\draw[BrickRed]([shift={({(\\x-1)*\\gzk},-\\y*0.38)}]khT1)rectangle++(\\ttkc,-\\ttkg);
	\\foreach \\x in {1,2,...,\\khws}
	\\foreach \\y in {0,1,...,9}
		\\draw[BrickRed]([shift={({(\\x-1)*\\gzk},-\\y*0.38)}]khTx)node{\\zihao{-6}\\textsf{\\y}};
	\\draw
		(XM)node[right]{\\heiti\\zihao{-4}姓名：\\tk[3.1]}
		([shift={(0,-0.8)}]XM)node[right]{\\heiti\\zihao{-4}助教：\\tk[3.1] }
		([shift={(0.2,-1.5)}]XM)node[right]{\\heiti\\zihao{5}学号}
		([shift={(2.8,-1.5)}]XM)node[right]{\\heiti\\zihao{5}编号};
	\\draw[BrickRed]([shift={(1.3,-1.8)}]XM)rectangle++(0.6,0.6)
				([shift={(1.9,-1.8)}]XM)rectangle++(0.6,0.6)
				([shift={(3.9,-1.8)}]XM)rectangle++(0.6,0.6)
				([shift={(4.5,-1.8)}]XM)rectangle++(0.6,0.6);
	\\draw[BrickRed]
		([shift={({\\lk/4},-1.9)}]XM)node[below=2pt]{\\heiti{注意事项}}
		([shift={(0,-2.9)}]XM)node[right]{\\zihao{6}
			\\begin{varwidth}[b]{\\lk/2-0.2cm}
				1.答题前，先将群昵称、年级（汉字）、准考证号、编号填写清楚；
			\\end{varwidth}
		}
		([shift={(0,-3.6)}]XM)node[right]{\\zihao{6}2.考号和选择题答案请使用2B铅笔填涂；}
		([shift={(0,-4.25)}]XM)node[right]{\\zihao{6}
			\\begin{varwidth}[b]{\\lk/2-0.2cm}
				3.非选择题请使用黑色笔，在指定区域内答题超出对应区域的答案无效.
			\\end{varwidth}
		};`;
  
  // 生成动态答题区域
  content += generateDynamicAnswerAreas(paper, stats);
  
  return content;
}

// 生成动态答题区域
function generateDynamicAnswerAreas(paper: IPaper, stats: any): string {
  let content = '';
  let currentY = 7.1; // 起始Y坐标
  let sectionIndex = 0;
  
  paper.sections.forEach((section, sectionIdx) => {
    // 按题目类型分组
    const questionsByType = new Map<string, any[]>();
    
    section.items.forEach(item => {
      const snap = item.snapshot as IQuestionSnapshot;
      const type = snap?.type || 'fill';
      if (!questionsByType.has(type)) {
        questionsByType.set(type, []);
      }
      questionsByType.get(type)!.push(item);
    });
    
    // 为每种题型生成答题区域
    questionsByType.forEach((questions, type) => {
      const totalScore = questions.reduce((sum, item) => sum + (item.score || 5), 0);
      const avgScore = Math.round(totalScore / questions.length);
      
      // 根据题型生成不同的答题区域
      switch (type) {
        case 'fill':
          // 填空题答题区域
          content += `\\fill[BrickRed!30]([shift={(0,-${currentY})}]A1)rectangle++({\\lk},-0.6);
	\\draw([shift={({\\lk/2},-${currentY})}]A1)node[below]{\\heiti\\zihao{-4}${getChineseNumber(sectionIndex + 1)}. \\quad 填空题（总共${questions.length}题，每题${avgScore}分，满分${totalScore}分）};
	\\draw[BrickRed]([shift={(0,-${currentY})}]A1)--++({\\lk},0);`;
          
          // 生成填空题答题区域
          questions.forEach((item, idx) => {
            // 根据当前题目在整体中的位置计算编号
            const questionNumber = getQuestionNumberByPosition(paper, stats, type, idx);
            const column = idx === 0 ? 'A2' : (idx === 1 ? 'A3' : 'A1');
            const yOffset = currentY + 0.8 + idx * 1.2;
            
            content += `\\draw([shift={(0.3,-${yOffset})}]${column})node[right]{{\\heiti ${questionNumber}.} \\tk[2]};`;
          });
          
          currentY += 2 + questions.length * 1.2;
          break;
          
        case 'choice':
          // 选择题答题区域
          content += `\\fill[BrickRed!30]([shift={(0,-${currentY})}]A1)rectangle++({\\lk},-0.6);
	\\draw([shift={({\\lk/2},-${currentY})}]A1)node[below]{\\heiti\\zihao{-4}${getChineseNumber(sectionIndex + 1)}. \\quad 选择题（总共${questions.length}题，每题${avgScore}分，满分${totalScore}分）};
	\\draw[BrickRed]([shift={(0,-${currentY})}]A1)--++({\\lk},0);`;
          
          // 生成选择题答题区域
          questions.forEach((item, idx) => {
            // 根据当前题目在整体中的位置计算编号
            const questionNumber = getQuestionNumberByPosition(paper, stats, type, idx);
            const column = idx === 0 ? 'A2' : (idx === 1 ? 'A3' : 'A1');
            const yOffset = currentY + 0.8 + idx * 1.2;
            
            content += `\\draw([shift={(0.3,-${yOffset})}]${column})node[right]{{\\heiti ${questionNumber}.} \\sxtt};`;
          });
          
          currentY += 2 + questions.length * 1.2;
          break;
          
        case 'multiple-choice':
          // 多选题答题区域
          content += `\\fill[BrickRed!30]([shift={(0,-${currentY})}]A1)rectangle++({\\lk},-0.6);
	\\draw([shift={({\\lk/2},-${currentY})}]A1)node[below]{\\heiti\\zihao{-4}${getChineseNumber(sectionIndex + 1)}. \\quad 多选题（总共${questions.length}题，每题${avgScore}分，满分${totalScore}分）};
	\\draw[BrickRed]([shift={(0,-${currentY})}]A1)--++({\\lk},0);`;
          
          // 生成多选题答题区域
          questions.forEach((item, idx) => {
            // 根据当前题目在整体中的位置计算编号
            const questionNumber = getQuestionNumberByPosition(paper, stats, type, idx);
            const column = idx === 0 ? 'A2' : (idx === 1 ? 'A3' : 'A1');
            const yOffset = currentY + 0.8 + idx * 1.2;
            
            content += `\\draw([shift={(0.3,-${yOffset})}]${column})node[right]{{\\heiti ${questionNumber}.} \\sxtt};`;
          });
          
          currentY += 2 + questions.length * 1.2;
          break;
          
        case 'solution':
          // 解答题答题区域
          content += `\\fill[BrickRed!30]([shift={(0,-${currentY})}]A1)rectangle++({\\lk},-0.6);
	\\draw([shift={({\\lk/2},-${currentY})}]A1)node[below]{\\heiti\\zihao{-4}${getChineseNumber(sectionIndex + 1)}. \\quad 解答题（总共${questions.length}题，满分${totalScore}分）};
	\\draw[BrickRed]([shift={(0,-${currentY})}]A1)--++({\\lk},0);`;
          
          // 生成解答题答题区域
          questions.forEach((item, idx) => {
            // 根据当前题目在整体中的位置计算编号
            const questionNumber = getQuestionNumberByPosition(paper, stats, type, idx);
            const column = idx === 0 ? 'A2' : (idx === 1 ? 'A3' : 'A1');
            const score = item.score || 10;
            const yOffset = currentY + 0.8 + idx * 1.2;
            
            content += `\\draw([shift={(0.3,-${yOffset})}]${column})node[right]{{\\heiti ${questionNumber}.}\\textbf{（本大题满分${score}分）}};
    \\draw([shift={(0.2,-${yOffset + 0.7})}]${column})node[right]{解：（1）};`;
          });
          
          currentY += 2 + questions.length * 1.2;
          break;
      }
      
      sectionIndex++;
    });
  });
  
  return content;
}

// 获取章节标题
function getSectionTitle(type: string, index: number): string {
  const titles = ['一', '二', '三', '四', '五'];
  const typeNames = {
    'fill': '填空题',
    'choice': '选择题',
    'multiple-choice': '多选题',
    'solution': '解答题'
  };
  return `${titles[index-1]}. \\quad ${typeNames[type as keyof typeof typeNames]}`;
}

// 获取章节总分
function getSectionScore(questionOrder: Array<{type: string, number: number, score: number}>, type: string): number {
  return questionOrder.filter((q: any) => q.type === type).reduce((sum: number, q: any) => sum + q.score, 0);
}

// 获取指定类型的所有题目
function getAllQuestionsByType(paper: IPaper, type: string): any[] {
  const questions: any[] = [];
  paper.sections.forEach(section => {
    section.items.forEach(item => {
      const snap = item.snapshot as IQuestionSnapshot;
      if (snap?.type === type) {
        questions.push(item);
      }
    });
  });
  return questions;
}

// 获取指定类型题目的起始编号
function getQuestionStartNumber(paper: IPaper, type: string): number {
  let currentNumber = 1;
  
  for (const section of paper.sections) {
    for (const item of section.items) {
      const snap = item.snapshot as IQuestionSnapshot;
      if (snap?.type === type) {
        return currentNumber;
      }
      currentNumber++;
    }
  }
  
  return 1;
}

// 获取指定类型题目在试卷中的章节编号
function getSectionNumber(paper: IPaper, type: string): number {
  const stats = calculatePaperStats(paper);
  const typeOrder = [];
  
  if (stats.fillCount > 0) typeOrder.push('fill');
  if (stats.choiceCount > 0) typeOrder.push('choice');
  if (stats.multipleChoiceCount > 0) typeOrder.push('multiple-choice');
  if (stats.solutionCount > 0) typeOrder.push('solution');
  
  return typeOrder.indexOf(type) + 1;
}

function difficultyBadge(d?: number) {
  if (!d) return ''; 
  if (d <= 2) return '\\bs';
  if (d === 3) return '\\mi';
  return '\\di';
}

// 智能估算 Practice 模板解答题答题区域行数
function computeAnswerAreaLinesForPractice(snap?: IQuestionSnapshot): number {
  if (!snap) return 5;
  const difficulty = Math.max(1, Math.min(5, Number(snap.difficulty || 3)));
  // 基础行数按难度映射：1→5，2→8，3→10，4→12，5→15（可按需调整）
  const baseByDifficulty = [0, 5, 8, 10, 12, 15];
  let lines = baseByDifficulty[difficulty] || 10;

  // 估算小问数量：优先从题干中统计 \subp，其次统计已经规范化后的 \item 数量
  const stem = String(snap.stem || '');
  const subpCount = (stem.match(/\\subp/g) || []).length;
  let enumItemCount = 0;
  const itemMatches = stem.match(/\\item\b/g);
  if (itemMatches) enumItemCount = itemMatches.length;
  const subQuestionCount = Math.max(subpCount, enumItemCount);

  // 每个小问增加一定行数（难度越高，每小问附加越多）
  if (subQuestionCount > 1) {
    const perSub = Math.max(2, Math.min(6, Math.floor(difficulty + 1))); // 1→2, 5→6
    lines += (subQuestionCount - 1) * perSub;
  }

  // 限制上下界，避免过小/过大（上限按需求约束为 18）
  lines = Math.max(5, Math.min(18, lines));
  return lines;
}

// 估算 Practice 模板单题占用的行数，用于 Needspace 智能分页
function estimatePracticeItemLines(params: {
  stem: string;
  mainStem: string;
  subproblemContent: string;
  optionsCount: number;
  isSolution: boolean;
  includeAnswers: boolean;
  analysisText: string;
  analysisAreaLines: number;
}): number {
  const line = (s: string) => Math.ceil(Math.max(1, s.replace(/\s+/g, ' ').length / 60));
  // 题干与子问大致行数
  let lines = 0;
  const stemText = params.subproblemContent ? params.mainStem : params.stem;
  lines += line(stemText);
  if (params.subproblemContent) {
    // 粗略估算子问数量和行数
    const subItems = (params.subproblemContent.match(/\\item\b/g) || []).length;
    lines += Math.max(subItems, 1);
  }
  // 选项块：每2个选项约1行（两列显示），至少加1行
  if (params.optionsCount > 0) {
    lines += Math.max(1, Math.ceil(params.optionsCount / 2));
  }
  // 解析或答题区
  if (params.includeAnswers && params.analysisText.trim().length > 0) {
    lines += line(params.analysisText) + 1; // answer 环境前后留白
  } else if (params.isSolution && params.analysisAreaLines > 0) {
    lines += Math.ceil(params.analysisAreaLines * 0.9); // 行高略低于 baselineskip
  }
  // 额外余量，避免页底粘连
  lines += 1;
  // 不设置上限，交由单页容量控制器裁切
  return Math.max(3, lines);
}

// Practice 模板单页最大行数（估算基于 baselineskip）
const PRACTICE_MAX_LINES_PER_PAGE = 38;

function escapeTex(input: string): string {
  // 先将反斜杠变为文字形式，避免如 \choice 在标题/作者中被识别为命令
  const withBackslash = String(input).replace(/\\/g, '\\textbackslash{}');
  return withBackslash.replace(/[&_#%$]/g, (m) => ({
    '&': '\\&',
    '_': '\\_',
    '#': '\\#',
    '%': '\\%',
    '$': '\\$'
  } as any)[m]);
}

export function writeLatexToWorkspace(paperId: string, latex: string, templateName: string = 'practice'): { dir: string; texPath: string } {
  const dir = path.join(process.cwd(), 'temp', 'exports', paperId);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  const texPath = path.join(dir, `paper-${paperId}.tex`);
  fs.writeFileSync(texPath, latex, 'utf8');
  
  // 根据模板类型复制相应的样式文件
  try {
    if (templateName === 'practice') {
      // 复制 problemlab.sty 用于练习模板
      const candidates = [
        path.join(process.cwd(), 'src', 'templates', 'latex', 'problemlab.sty'),
        path.join(process.cwd(), 'dist', 'templates', 'latex', 'problemlab.sty'),
        path.join(process.cwd(), 'templates', 'latex', 'problemlab.sty'),
        path.join(process.cwd(), 'problemlab.sty'),
        path.join(process.cwd(), '..', 'problemlab.sty'),
        path.join(process.cwd(), '..', '..', 'problemlab.sty')
      ];
      const tpl = candidates.find(p => fs.existsSync(p));
      if (tpl) {
        fs.copyFileSync(tpl, path.join(dir, 'problemlab.sty'));
      } else {
        console.warn('problemlab.sty 未找到，建议检查模板路径');
      }
    } else if (templateName === 'test' || templateName === 'answersheet') {
      // 测试模板和答题卡模板不需要额外的样式文件，使用 ctex 文档类
      console.log(`使用 ${templateName} 模板，无需复制额外样式文件`);
    }
  } catch (e) {
    console.warn('复制模板文件失败:', e);
  }
  return { dir, texPath };
}

// ========== 规范化与提取 ==========

function normalizeStemAndExtractOptions(input: string): { stem: string; options: string[] } {
  let stem = input;
  const options: string[] = [];

  // 0) 将字面量 \n 转为实际换行，并折叠命令处双反斜杠为单反斜杠（不影响行末换行）
  stem = stem.replace(/\\n\s*/g, '\n');
  stem = collapseEscapedBackslashes(stem);

  // 1) 将自定义层级 \subp / \endsubp, \subsubp / \endsubsubp 转换为模板环境
  // 注意：这里只做基本的转换，具体的环境处理由 processSubpStructure 完成
  stem = stem.replace(/\\subp\b/g, '\\subp')
             .replace(/\\endsubp\b/g, '\\endsubp')
             .replace(/\\subsubp\b/g, '\\subsubp')
             .replace(/\\endsubsubp\b/g, '\\endsubsubp');

  // 2) 填空：谨慎替换 \fill（避开 TikZ 的 \fill( ... / \fill[ ... / \fill{ ...）
  // 匹配独立的 \fill，且后面不是 [ { ( 字符
  stem = stem.replace(/\\fill(?!\s*[\[\{\(])/g, '\\underlines');

  // 3) 提取"行首"\choice 作为选项（用于旧写法），但题干"内联"\choice 不视为选项
  const lineChoices: RegExp = /^\s*\\choice(?:\s*[A-H]\.)?\s*(.+)$/gmi;
  const lineCollected: string[] = [];
  stem = stem.replace(lineChoices, (_: string, txt: string) => {
    if (txt && txt.trim()) lineCollected.push(txt.trim());
    return '';
  });
  const multiChoiceRegex: RegExp = /^(.*)\n?\\choice\s*((?:\{[^}]*\}\s*){2,8})/m; // 仅匹配行首样式
  let m: RegExpExecArray | null;
  while ((m = multiChoiceRegex.exec(stem)) !== null) {
    const group = m[2];
    const braceContents = Array.from(group.matchAll(/\{([^}]*)\}/g)).map(mm => (mm[1] || '').trim());
    for (const b of braceContents) if (b) lineCollected.push(b);
    stem = stem.replace(m[0], m[1]);
  }
  if (lineCollected.length > 0) options.push(...lineCollected);

  // 4) 将题干中的"内联"\choice 视为填空符，替换为 \dotfill （\qquad \qquad）
  // 保持与前端/模板一致的视觉占位宽度
  stem = stem.replace(/\\choice\b/g, '\\dotfill （\\qquad \\\\qquad）');

  // 5) 清理多余空行
  stem = stem.replace(/\n{3,}/g, '\n\n');
  // 6) 收尾再将任何残留的字面量 \n 转换为真实换行
  stem = stem.replace(/\\n/g, '\n');

  return { stem, options };
}

// 将如 \\begin、\\draw 折叠为 \begin、\draw（不处理行末换行的 \\）
function collapseEscapedBackslashes(s: string): string {
  return String(s).replace(/\\\\(?=[A-Za-z@])/g, '\\');
}

function appendSourceToBadge(badge: string, source?: string): string {
  if (!badge) return '';
  if (!source) return badge;
  const esc = escapeTex(source);
  if (badge.startsWith('\\bs')) return `\\bs[${esc}]`;
  if (badge.startsWith('\\mi')) return `\\mi[${esc}]`;
  if (badge.startsWith('\\di')) return `\\di[${esc}]`;
  return badge;
}

// 处理LaTeX命令转换
function processLatexCommands(content: string, templateName: string): string {
  // 处理反斜杠转义
  content = collapseEscapedBackslashes(content);
  
  // 处理换行符
  content = content.replace(/\\n/g, '\n');
  
  // 根据模板类型进行不同的转换
  if (templateName === 'practice') {
    // 练习模板的转换
    content = content
      .replace(/\\fill/g, '\\underlines')
      .replace(/\\choice/g, '\\dotfill （\\qquad \\qquad）');
    
    // 处理 subp 和 subsubp 的嵌套结构
    content = processSubpStructure(content, 'practice');
  } else if (templateName === 'test' || templateName === 'answersheet') {
    // 测试模板和答题卡模板的转换
    content = content
      .replace(/\\fill/g, '\\underlines')
      .replace(/\\choice/g, '\\dotfill （\\qquad \\qquad）');
    
    // 处理 subp 和 subsubp 的嵌套结构
    content = processSubpStructure(content, templateName);
  }
  
  return content;
}

// 处理 subp 和 subsubp 的嵌套结构
function processSubpStructure(content: string, templateName: string): string {
  if (templateName === 'practice') {
    // 练习模板：使用 problemlab.sty 的复杂环境
    
    // 处理嵌套的 subsubp 结构
    content = content.replace(/\\subp([\s\S]*?)\\endsubp/g, (match, inner) => {
      // 先处理内部的 subsubp
      const processedInner = inner.replace(/\\subsubp([\s\S]*?)\\endsubsubp/g, (subMatch: string, subInner: string) => {
        return `\\begin{subsubproblem}\n\\item ${subInner.trim()}\n\\end{subsubproblem}`;
      });
      
      // 处理没有 \endsubsubp 的 subsubp
      const finalInner = processedInner.replace(/\\subsubp/g, '\\item');
      
      return `\\begin{subproblem}\n\\item ${finalInner.trim()}\n\\end{subproblem}`;
    });
    
    // 处理没有 \endsubp 的 subp 和 subsubp
    if (content.includes('\\subp') || content.includes('\\subsubp')) {
      // 先清理任何剩余的结束标记
      content = content.replace(/\\endsubsubp/g, '');
      content = content.replace(/\\endsubp/g, '');
      
      // 使用正则表达式来处理嵌套结构
      // 首先处理 subsubp，将所有 subsubp 包装在一个 subsubproblem 环境中
      if (content.includes('\\subsubp')) {
        // 使用正则表达式找到所有 \subsubp 及其内容
        const subsubpRegex = /\\subsubp([\s\S]*?)(?=\\subsubp|\\subp|$)/g;
        const matches = [];
        let match;
        
        while ((match = subsubpRegex.exec(content)) !== null) {
          matches.push(match[1].trim());
        }
        
        if (matches.length > 0) {
          // 找到第一个 \subsubp 的位置
          const firstSubsubpIndex = content.indexOf('\\subsubp');
          const beforeSubsubp = content.substring(0, firstSubsubpIndex);
          
          // 找到最后一个 \subsubp 的位置
          const lastSubsubpIndex = content.lastIndexOf('\\subsubp');
          
          // 找到最后一个 \subsubp 后的内容
          const lastSubsubpContent = content.substring(lastSubsubpIndex);
          const lastSubsubpEndMatch = lastSubsubpContent.match(/\\subsubp([\s\S]*?)(?=\\subsubp|\\subp|$)/);
          const lastSubsubpEndIndex = lastSubsubpIndex + (lastSubsubpEndMatch ? lastSubsubpEndMatch[0].length : 0);
          const afterSubsubp = content.substring(lastSubsubpEndIndex);
          
          // 创建所有的 items
          const items = matches.map(m => `\\item ${m}`).join('\n');
          
          // 重新组装内容
          content = beforeSubsubp + '\\begin{subsubproblem}\n' + items + '\n\\end{subsubproblem}' + afterSubsubp;
        }
      }
      
      // 然后处理 subp，将所有 subp 包装在一个 subproblem 环境中
      if (content.includes('\\subp')) {
        // 使用正则表达式找到所有 \subp 及其内容
        const subpRegex = /\\subp([\s\S]*?)(?=\\subp|$)/g;
        const matches = [];
        let match;
        
        while ((match = subpRegex.exec(content)) !== null) {
          matches.push(match[1].trim());
        }
        
        if (matches.length > 0) {
          // 找到第一个 \subp 的位置
          const firstSubpIndex = content.indexOf('\\subp');
          const beforeSubp = content.substring(0, firstSubpIndex);
          
          // 找到最后一个 \subp 的位置
          const lastSubpIndex = content.lastIndexOf('\\subp');
          
          // 找到最后一个 \subp 后的内容
          const lastSubpContent = content.substring(lastSubpIndex);
          const lastSubpEndMatch = lastSubpContent.match(/\\subp([\s\S]*?)(?=\\subp|$)/);
          const lastSubpEndIndex = lastSubpIndex + (lastSubpEndMatch ? lastSubpEndMatch[0].length : 0);
          const afterSubp = content.substring(lastSubpEndIndex);
          
          // 创建所有的 items
          const items = matches.map(m => `\\item ${m}`).join('\n');
          
          // 重新组装内容
          content = beforeSubp + '\\begin{subproblem}\n' + items + '\n\\end{subproblem}' + afterSubp;
        }
      }
    }
    
  } else if (templateName === 'test' || templateName === 'answersheet') {
    // 测试模板和答题卡模板：使用简单的 enumerate 环境
    
    // 处理嵌套的 subsubp 结构
    content = content.replace(/\\subp([\s\S]*?)\\endsubp/g, (match, inner) => {
      // 先处理内部的 subsubp
      const processedInner = inner.replace(/\\subsubp([\s\S]*?)\\endsubsubp/g, (subMatch: string, subInner: string) => {
        return `\\begin{enumerate}[label=\\textcircled{\\arabic*}]\n\\item ${subInner.trim()}\n\\end{enumerate}`;
      });
      
      // 处理没有 \endsubsubp 的 subsubp
      const finalInner = processedInner.replace(/\\subsubp/g, '\\item');
      
      return `\\item ${finalInner.trim()}`;
    });
    
    // 处理没有 \endsubp 的 subp - 这是关键修复
    content = content.replace(/\\subp([\s\S]*?)(?=\\subp|$)/g, (match, inner) => {
      // 先处理内部的 subsubp
      const processedInner = inner.replace(/\\subsubp([\s\S]*?)\\endsubsubp/g, (subMatch: string, subInner: string) => {
        return `\\begin{enumerate}[label=\\textcircled{\\arabic*}]\n\\item ${subInner.trim()}\n\\end{enumerate}`;
      });
      
      // 处理没有 \endsubsubp 的 subsubp
      const finalInner = processedInner.replace(/\\subsubp/g, '\\item');
      
      return `\\item ${finalInner.trim()}`;
    });
    
    // 最后清理任何剩余的标记
    content = content.replace(/\\endsubp/g, '')
                    .replace(/\\subsubp/g, '\\item')
                    .replace(/\\endsubsubp/g, '');
  }
  
  return content;
}

// 解析模板文件（兼容开发与生产路径）
function resolveTemplatePath(filename: string): string {
  const candidates = [
    path.join(process.cwd(), 'src', 'templates', 'latex', filename),
    path.join(process.cwd(), 'dist', 'templates', 'latex', filename),
    path.join(process.cwd(), 'templates', 'latex', filename),
    path.join(__dirname, '..', '..', 'templates', 'latex', filename),
  ];
  for (const p of candidates) {
    if (fs.existsSync(p)) return p;
  }
  throw new Error(`模板文件未找到: ${filename}; 搜索路径: \n${candidates.join('\n')}`);
}


