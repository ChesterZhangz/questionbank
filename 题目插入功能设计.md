# é¢˜ç›®æ’å…¥åŠŸèƒ½è®¾è®¡æ–¹æ¡ˆ

## 1. åŠŸèƒ½æ¦‚è¿°

### 1.1 æ ¸å¿ƒéœ€æ±‚
- **æ‹–æ‹½æ’å…¥**ï¼šä»é¢˜ç›®åˆ—è¡¨æ‹–æ‹½é¢˜ç›®åˆ°ç¼–è¾‘å™¨æŒ‡å®šä½ç½®
- **é¢˜ç›®æ¸²æŸ“**ï¼šåœ¨ç¼–è¾‘å™¨ä¸­ä»¥ç‰¹æ®Šæ ¼å¼æ˜¾ç¤ºé¢˜ç›®å†…å®¹
- **é¢˜ç›®ç¼–è¾‘**ï¼šæ”¯æŒåœ¨ç¼–è¾‘å™¨ä¸­ç›´æ¥ç¼–è¾‘é¢˜ç›®å†…å®¹
- **é¢˜ç›®åˆ é™¤**ï¼šå¯ä»¥åˆ é™¤å·²æ’å…¥çš„é¢˜ç›®
- **é¢˜ç›®å¼•ç”¨**ï¼šä¿æŒä¸åŸå§‹é¢˜ç›®çš„å…³è”å…³ç³»

### 1.2 ç”¨æˆ·ä½“éªŒæµç¨‹
1. ç”¨æˆ·åœ¨é¢˜åº“ä¸­é€‰æ‹©é¢˜ç›®
2. æ‹–æ‹½é¢˜ç›®åˆ°ç¼–è¾‘å™¨ä¸­çš„ç›®æ ‡ä½ç½®
3. é¢˜ç›®ä»¥ç‰¹æ®Šæ ¼å¼æ’å…¥åˆ°ç¼–è¾‘å™¨ä¸­
4. ç”¨æˆ·å¯ä»¥ç»§ç»­ç¼–è¾‘é¢˜ç›®å†…å®¹
5. æ”¯æŒé¢˜ç›®çš„åˆ é™¤å’Œé‡æ–°æ’å…¥

## 2. æŠ€æœ¯å®ç°æ–¹æ¡ˆ

### 2.1 é¢˜ç›®æ•°æ®ç»“æ„è®¾è®¡
```typescript
interface QuestionElement {
  id: string;                    // é¢˜ç›®å”¯ä¸€æ ‡è¯†
  type: 'question';              // å…ƒç´ ç±»å‹
  questionId: string;            // åŸå§‹é¢˜ç›®ID
  content: string;               // é¢˜ç›®å†…å®¹ï¼ˆMarkdownæ ¼å¼ï¼‰
  metadata: {
    title: string;               // é¢˜ç›®æ ‡é¢˜
    difficulty: number;          // éš¾åº¦ç­‰çº§
    category: string;            // é¢˜ç›®åˆ†ç±»
    tags: string[];              // æ ‡ç­¾
    source: string;              // æ¥æºé¢˜åº“
  };
  position: {
    line: number;                // æ’å…¥è¡Œå·
    column: number;              // æ’å…¥åˆ—å·
  };
  editable: boolean;             // æ˜¯å¦å¯ç¼–è¾‘
}
```

### 2.2 é¢˜ç›®æ’å…¥æœºåˆ¶

#### 2.2.1 æ‹–æ‹½æ’å…¥
```typescript
// æ‹–æ‹½æºï¼šé¢˜ç›®åˆ—è¡¨
interface QuestionDragSource {
  questionId: string;
  questionData: Question;
  dragType: 'question';
}

// æ‹–æ‹½ç›®æ ‡ï¼šç¼–è¾‘å™¨
interface EditorDropTarget {
  position: { line: number; column: number };
  insertMode: 'replace' | 'insert';
}
```

#### 2.2.2 æ’å…¥ä½ç½®è®¡ç®—
```typescript
// è®¡ç®—æ‹–æ‹½ä½ç½®å¯¹åº”çš„ç¼–è¾‘å™¨ä½ç½®
function calculateInsertPosition(event: DragEvent): InsertPosition {
  const editor = getEditorElement();
  const rect = editor.getBoundingClientRect();
  
  // è®¡ç®—é¼ æ ‡ä½ç½®ç›¸å¯¹äºç¼–è¾‘å™¨çš„åæ ‡
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  
  // ä½¿ç”¨Range APIæ‰¾åˆ°æœ€è¿‘çš„æ–‡æœ¬ä½ç½®
  const range = document.caretRangeFromPoint(event.clientX, event.clientY);
  
  return {
    line: getLineNumber(range),
    column: getColumnNumber(range),
    range: range
  };
}
```

### 2.3 é¢˜ç›®æ¸²æŸ“æ–¹æ¡ˆ

#### 2.3.1 é¢˜ç›®å…ƒç´ æ ‡è¯†
```typescript
// åœ¨Markdownä¸­ä½¿ç”¨ç‰¹æ®Šè¯­æ³•æ ‡è¯†é¢˜ç›®
const QUESTION_SYNTAX = /^@question\{([^}]+)\}(.*?)(?=^@question\{|\n\n|$)/gms;

// ç¤ºä¾‹ï¼š
// @question{question-id-123}
// è¿™æ˜¯ä¸€é“æ•°å­¦é¢˜...
// é€‰é¡¹A: ...
// é€‰é¡¹B: ...
// @end
```

#### 2.3.2 é¢˜ç›®æ¸²æŸ“å™¨
```typescript
class QuestionRenderer {
  // å°†é¢˜ç›®è¯­æ³•æ¸²æŸ“ä¸ºHTML
  renderQuestion(match: string, questionId: string, content: string): string {
    return `
      <div class="question-element" data-question-id="${questionId}">
        <div class="question-header">
          <span class="question-icon">ğŸ“</span>
          <span class="question-title">é¢˜ç›® ${questionId}</span>
          <button class="question-edit-btn">ç¼–è¾‘</button>
          <button class="question-delete-btn">åˆ é™¤</button>
        </div>
        <div class="question-content">
          ${this.renderQuestionContent(content)}
        </div>
      </div>
    `;
  }
  
  // æ¸²æŸ“é¢˜ç›®å†…å®¹ï¼ˆæ”¯æŒLaTeXã€å›¾ç‰‡ç­‰ï¼‰
  private renderQuestionContent(content: string): string {
    // 1. è§£æLaTeXå…¬å¼
    content = this.renderLatex(content);
    
    // 2. è§£æå›¾ç‰‡
    content = this.renderImages(content);
    
    // 3. è§£æå…¶ä»–Markdownè¯­æ³•
    content = this.renderMarkdown(content);
    
    return content;
  }
}
```

### 2.4 é¢˜ç›®ç¼–è¾‘åŠŸèƒ½

#### 2.4.1 ç¼–è¾‘æ¨¡å¼åˆ‡æ¢
```typescript
class QuestionEditor {
  // è¿›å…¥é¢˜ç›®ç¼–è¾‘æ¨¡å¼
  enterEditMode(questionElement: HTMLElement): void {
    // 1. ä¿å­˜åŸå§‹å†…å®¹
    const originalContent = questionElement.dataset.originalContent;
    
    // 2. åˆ‡æ¢åˆ°ç¼–è¾‘æ¨¡å¼
    questionElement.classList.add('editing');
    questionElement.contentEditable = 'true';
    
    // 3. æ˜¾ç¤ºç¼–è¾‘å·¥å…·æ 
    this.showEditToolbar(questionElement);
    
    // 4. èšç„¦åˆ°ç¼–è¾‘åŒºåŸŸ
    questionElement.focus();
  }
  
  // é€€å‡ºç¼–è¾‘æ¨¡å¼
  exitEditMode(questionElement: HTMLElement): void {
    // 1. ä¿å­˜ç¼–è¾‘å†…å®¹
    const editedContent = questionElement.textContent;
    
    // 2. é‡æ–°æ¸²æŸ“é¢˜ç›®
    this.rerenderQuestion(questionElement, editedContent);
    
    // 3. é€€å‡ºç¼–è¾‘æ¨¡å¼
    questionElement.classList.remove('editing');
    questionElement.contentEditable = 'false';
    
    // 4. éšè—ç¼–è¾‘å·¥å…·æ 
    this.hideEditToolbar(questionElement);
  }
}
```

#### 2.4.2 é¢˜ç›®å†…å®¹åŒæ­¥
```typescript
// é¢˜ç›®å†…å®¹å˜æ›´æ—¶çš„å¤„ç†
function handleQuestionContentChange(questionElement: HTMLElement): void {
  const questionId = questionElement.dataset.questionId;
  const newContent = questionElement.textContent;
  
  // 1. æ›´æ–°é¢˜ç›®æ•°æ®
  updateQuestionData(questionId, newContent);
  
  // 2. è§¦å‘ç¼–è¾‘å™¨å†…å®¹å˜æ›´
  triggerEditorChange();
  
  // 3. é‡æ–°æ¸²æŸ“é¢˜ç›®ï¼ˆå¦‚æœéœ€è¦ï¼‰
  if (shouldRerender(questionElement)) {
    rerenderQuestion(questionElement);
  }
}
```

## 3. ä¸å³æ—¶æ¸²æŸ“ç¼–è¾‘å™¨çš„é›†æˆ

### 3.1 é¢˜ç›®è¯­æ³•è§£æ
```typescript
// åœ¨Markdownè§£æå™¨ä¸­æ·»åŠ é¢˜ç›®è¯­æ³•æ”¯æŒ
class MarkdownParser {
  parse(content: string): string {
    let html = content;
    
    // 1. è§£æé¢˜ç›®è¯­æ³•
    html = this.parseQuestions(html);
    
    // 2. è§£æå…¶ä»–Markdownè¯­æ³•
    html = this.parseMarkdown(html);
    
    return html;
  }
  
  private parseQuestions(content: string): string {
    return content.replace(QUESTION_SYNTAX, (match, questionId, content) => {
      return this.questionRenderer.renderQuestion(match, questionId, content);
    });
  }
}
```

### 3.2 å…‰æ ‡ç®¡ç†é€‚é…
```typescript
// åœ¨å…‰æ ‡ç®¡ç†ä¸­æ·»åŠ é¢˜ç›®å…ƒç´ æ”¯æŒ
class CursorManager {
  // ä¿å­˜å…‰æ ‡ä½ç½®æ—¶è€ƒè™‘é¢˜ç›®å…ƒç´ 
  saveCursor(): CursorInfo {
    const selection = window.getSelection();
    const range = selection.getRangeAt(0);
    
    // æ£€æŸ¥å…‰æ ‡æ˜¯å¦åœ¨é¢˜ç›®å…ƒç´ å†…
    const questionElement = this.findQuestionElement(range.startContainer);
    
    if (questionElement) {
      return {
        type: 'question',
        questionId: questionElement.dataset.questionId,
        offset: this.getOffsetInQuestion(questionElement, range),
        isEditing: questionElement.classList.contains('editing')
      };
    }
    
    // æ™®é€šæ–‡æœ¬å…‰æ ‡å¤„ç†
    return this.saveTextCursor(range);
  }
  
  // æ¢å¤å…‰æ ‡ä½ç½®æ—¶è€ƒè™‘é¢˜ç›®å…ƒç´ 
  restoreCursor(cursorInfo: CursorInfo): void {
    if (cursorInfo.type === 'question') {
      this.restoreQuestionCursor(cursorInfo);
    } else {
      this.restoreTextCursor(cursorInfo);
    }
  }
}
```

### 3.3 äº‹ä»¶å¤„ç†é›†æˆ
```typescript
// åœ¨ç¼–è¾‘å™¨äº‹ä»¶å¤„ç†ä¸­æ·»åŠ é¢˜ç›®ç›¸å…³äº‹ä»¶
class EditorEventHandler {
  setupEventListeners(): void {
    // 1. åŸºç¡€ç¼–è¾‘å™¨äº‹ä»¶
    this.editor.addEventListener('input', this.handleInput.bind(this));
    this.editor.addEventListener('keydown', this.handleKeydown.bind(this));
    
    // 2. é¢˜ç›®ç›¸å…³äº‹ä»¶
    this.editor.addEventListener('click', this.handleQuestionClick.bind(this));
    this.editor.addEventListener('dragstart', this.handleDragStart.bind(this));
    this.editor.addEventListener('dragover', this.handleDragOver.bind(this));
    this.editor.addEventListener('drop', this.handleDrop.bind(this));
  }
  
  // å¤„ç†é¢˜ç›®ç‚¹å‡»äº‹ä»¶
  private handleQuestionClick(event: MouseEvent): void {
    const questionElement = this.findQuestionElement(event.target);
    if (questionElement) {
      this.handleQuestionInteraction(questionElement, event);
    }
  }
  
  // å¤„ç†æ‹–æ‹½å¼€å§‹
  private handleDragStart(event: DragEvent): void {
    const questionElement = this.findQuestionElement(event.target);
    if (questionElement) {
      event.dataTransfer.setData('text/plain', questionElement.dataset.questionId);
      event.dataTransfer.effectAllowed = 'move';
    }
  }
  
  // å¤„ç†æ‹–æ‹½æ”¾ç½®
  private handleDrop(event: DragEvent): void {
    event.preventDefault();
    
    const questionId = event.dataTransfer.getData('text/plain');
    const position = this.calculateInsertPosition(event);
    
    this.insertQuestion(questionId, position);
  }
}
```

## 4. ç”¨æˆ·ç•Œé¢è®¾è®¡

### 4.1 é¢˜ç›®é€‰æ‹©ç•Œé¢
```typescript
interface QuestionSelector {
  // é¢˜ç›®åˆ—è¡¨æ˜¾ç¤º
  showQuestionList(questions: Question[]): void;
  
  // é¢˜ç›®æœç´¢å’Œç­›é€‰
  filterQuestions(criteria: FilterCriteria): Question[];
  
  // æ‹–æ‹½é¢„è§ˆ
  showDragPreview(question: Question): void;
}
```

### 4.2 é¢˜ç›®ç¼–è¾‘ç•Œé¢
```typescript
interface QuestionEditInterface {
  // ç¼–è¾‘å·¥å…·æ 
  showEditToolbar(questionElement: HTMLElement): void;
  
  // é¢˜ç›®å±æ€§ç¼–è¾‘
  editQuestionProperties(questionId: string): void;
  
  // é¢˜ç›®å†…å®¹ç¼–è¾‘
  editQuestionContent(questionId: string): void;
}
```

### 4.3 é¢˜ç›®çŠ¶æ€æŒ‡ç¤º
```typescript
// é¢˜ç›®çŠ¶æ€å¯è§†åŒ–
enum QuestionStatus {
  NORMAL = 'normal',           // æ­£å¸¸çŠ¶æ€
  EDITING = 'editing',         // ç¼–è¾‘ä¸­
  MODIFIED = 'modified',       // å·²ä¿®æ”¹
  ERROR = 'error',            // é”™è¯¯çŠ¶æ€
  LOADING = 'loading'         // åŠ è½½ä¸­
}

// çŠ¶æ€æ ·å¼
const statusStyles = {
  [QuestionStatus.NORMAL]: 'question-normal',
  [QuestionStatus.EDITING]: 'question-editing',
  [QuestionStatus.MODIFIED]: 'question-modified',
  [QuestionStatus.ERROR]: 'question-error',
  [QuestionStatus.LOADING]: 'question-loading'
};
```

## 5. æ•°æ®ç®¡ç†

### 5.1 é¢˜ç›®æ•°æ®åŒæ­¥
```typescript
class QuestionDataManager {
  // é¢˜ç›®æ•°æ®ç¼“å­˜
  private questionCache: Map<string, Question> = new Map();
  
  // è·å–é¢˜ç›®æ•°æ®
  async getQuestion(questionId: string): Promise<Question> {
    if (this.questionCache.has(questionId)) {
      return this.questionCache.get(questionId);
    }
    
    const question = await this.fetchQuestion(questionId);
    this.questionCache.set(questionId, question);
    return question;
  }
  
  // æ›´æ–°é¢˜ç›®æ•°æ®
  async updateQuestion(questionId: string, content: string): Promise<void> {
    const question = this.questionCache.get(questionId);
    if (question) {
      question.content = content;
      question.modifiedAt = new Date();
      
      // åŒæ­¥åˆ°æœåŠ¡å™¨
      await this.syncQuestion(question);
    }
  }
}
```

### 5.2 é¢˜ç›®å¼•ç”¨ç®¡ç†
```typescript
class QuestionReferenceManager {
  // é¢˜ç›®å¼•ç”¨å…³ç³»
  private references: Map<string, string[]> = new Map();
  
  // æ·»åŠ é¢˜ç›®å¼•ç”¨
  addReference(lectureId: string, questionId: string): void {
    if (!this.references.has(lectureId)) {
      this.references.set(lectureId, []);
    }
    
    const refs = this.references.get(lectureId);
    if (!refs.includes(questionId)) {
      refs.push(questionId);
    }
  }
  
  // ç§»é™¤é¢˜ç›®å¼•ç”¨
  removeReference(lectureId: string, questionId: string): void {
    const refs = this.references.get(lectureId);
    if (refs) {
      const index = refs.indexOf(questionId);
      if (index > -1) {
        refs.splice(index, 1);
      }
    }
  }
}
```

## 6. æ€§èƒ½ä¼˜åŒ–

### 6.1 é¢˜ç›®æ¸²æŸ“ä¼˜åŒ–
```typescript
// é¢˜ç›®æ¸²æŸ“ä¼˜åŒ–ç­–ç•¥
class QuestionRenderOptimizer {
  // æ‡’åŠ è½½é¢˜ç›®å†…å®¹
  lazyLoadQuestion(questionElement: HTMLElement): void {
    const questionId = questionElement.dataset.questionId;
    
    // æ˜¾ç¤ºå ä½ç¬¦
    questionElement.innerHTML = this.createPlaceholder();
    
    // å¼‚æ­¥åŠ è½½é¢˜ç›®å†…å®¹
    this.loadQuestionContent(questionId).then(content => {
      questionElement.innerHTML = content;
    });
  }
  
  // è™šæ‹Ÿæ»šåŠ¨ï¼ˆå¤§é‡é¢˜ç›®æ—¶ï¼‰
  virtualScroll(container: HTMLElement): void {
    // åªæ¸²æŸ“å¯è§åŒºåŸŸçš„é¢˜ç›®
    const visibleRange = this.calculateVisibleRange(container);
    this.renderVisibleQuestions(visibleRange);
  }
}
```

### 6.2 äº‹ä»¶å¤„ç†ä¼˜åŒ–
```typescript
// äº‹ä»¶å¤„ç†ä¼˜åŒ–
class EventOptimizer {
  // äº‹ä»¶å§”æ‰˜
  setupEventDelegation(): void {
    this.editor.addEventListener('click', (event) => {
      const target = event.target as HTMLElement;
      
      if (target.classList.contains('question-edit-btn')) {
        this.handleEditClick(target);
      } else if (target.classList.contains('question-delete-btn')) {
        this.handleDeleteClick(target);
      }
    });
  }
  
  // é˜²æŠ–å¤„ç†
  debounceQuestionUpdate(questionId: string, content: string): void {
    clearTimeout(this.updateTimers.get(questionId));
    this.updateTimers.set(questionId, setTimeout(() => {
      this.updateQuestion(questionId, content);
    }, 500));
  }
}
```

## 7. é”™è¯¯å¤„ç†

### 7.1 é¢˜ç›®åŠ è½½é”™è¯¯
```typescript
class QuestionErrorHandler {
  // é¢˜ç›®åŠ è½½å¤±è´¥å¤„ç†
  handleLoadError(questionId: string, error: Error): void {
    console.error(`Failed to load question ${questionId}:`, error);
    
    // æ˜¾ç¤ºé”™è¯¯å ä½ç¬¦
    this.showErrorPlaceholder(questionId, error.message);
    
    // æä¾›é‡è¯•é€‰é¡¹
    this.showRetryOption(questionId);
  }
  
  // é¢˜ç›®æ¸²æŸ“é”™è¯¯å¤„ç†
  handleRenderError(questionElement: HTMLElement, error: Error): void {
    questionElement.classList.add('error');
    questionElement.innerHTML = `
      <div class="question-error">
        <span class="error-icon">âš ï¸</span>
        <span class="error-message">é¢˜ç›®æ¸²æŸ“å¤±è´¥</span>
        <button class="retry-btn">é‡è¯•</button>
      </div>
    `;
  }
}
```

## 8. æ€»ç»“

é¢˜ç›®æ’å…¥åŠŸèƒ½çš„å®ç°éœ€è¦ï¼š

1. **æ•°æ®ç»“æ„è®¾è®¡**ï¼šæ¸…æ™°çš„é¢˜ç›®å…ƒç´ æ•°æ®ç»“æ„
2. **æ‹–æ‹½æœºåˆ¶**ï¼šå®Œæ•´çš„æ‹–æ‹½æ’å…¥æµç¨‹
3. **æ¸²æŸ“ç³»ç»Ÿ**ï¼šé¢˜ç›®è¯­æ³•çš„è§£æå’Œæ¸²æŸ“
4. **ç¼–è¾‘åŠŸèƒ½**ï¼šé¢˜ç›®çš„å†…è”ç¼–è¾‘èƒ½åŠ›
5. **å…‰æ ‡ç®¡ç†**ï¼šä¸å³æ—¶æ¸²æŸ“ç¼–è¾‘å™¨çš„å…‰æ ‡ç®¡ç†é›†æˆ
6. **äº‹ä»¶å¤„ç†**ï¼šé¢˜ç›®ç›¸å…³äº‹ä»¶çš„ç»Ÿä¸€å¤„ç†
7. **æ•°æ®åŒæ­¥**ï¼šé¢˜ç›®æ•°æ®çš„ç¼“å­˜å’ŒåŒæ­¥
8. **æ€§èƒ½ä¼˜åŒ–**ï¼šæ‡’åŠ è½½ã€è™šæ‹Ÿæ»šåŠ¨ç­‰ä¼˜åŒ–ç­–ç•¥
9. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

è¿™ä¸ªè®¾è®¡å¯ä»¥å®Œç¾é›†æˆåˆ°å³æ—¶æ¸²æŸ“ç¼–è¾‘å™¨ä¸­ï¼Œæä¾›æµç•…çš„é¢˜ç›®æ’å…¥å’Œç¼–è¾‘ä½“éªŒã€‚
