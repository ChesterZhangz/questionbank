# 题目插入功能设计方案

## 1. 功能概述

### 1.1 核心需求
- **拖拽插入**：从题目列表拖拽题目到编辑器指定位置
- **题目渲染**：在编辑器中以特殊格式显示题目内容
- **题目编辑**：支持在编辑器中直接编辑题目内容
- **题目删除**：可以删除已插入的题目
- **题目引用**：保持与原始题目的关联关系

### 1.2 用户体验流程
1. 用户在题库中选择题目
2. 拖拽题目到编辑器中的目标位置
3. 题目以特殊格式插入到编辑器中
4. 用户可以继续编辑题目内容
5. 支持题目的删除和重新插入

## 2. 技术实现方案

### 2.1 题目数据结构设计
```typescript
interface QuestionElement {
  id: string;                    // 题目唯一标识
  type: 'question';              // 元素类型
  questionId: string;            // 原始题目ID
  content: string;               // 题目内容（Markdown格式）
  metadata: {
    title: string;               // 题目标题
    difficulty: number;          // 难度等级
    category: string;            // 题目分类
    tags: string[];              // 标签
    source: string;              // 来源题库
  };
  position: {
    line: number;                // 插入行号
    column: number;              // 插入列号
  };
  editable: boolean;             // 是否可编辑
}
```

### 2.2 题目插入机制

#### 2.2.1 拖拽插入
```typescript
// 拖拽源：题目列表
interface QuestionDragSource {
  questionId: string;
  questionData: Question;
  dragType: 'question';
}

// 拖拽目标：编辑器
interface EditorDropTarget {
  position: { line: number; column: number };
  insertMode: 'replace' | 'insert';
}
```

#### 2.2.2 插入位置计算
```typescript
// 计算拖拽位置对应的编辑器位置
function calculateInsertPosition(event: DragEvent): InsertPosition {
  const editor = getEditorElement();
  const rect = editor.getBoundingClientRect();
  
  // 计算鼠标位置相对于编辑器的坐标
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  
  // 使用Range API找到最近的文本位置
  const range = document.caretRangeFromPoint(event.clientX, event.clientY);
  
  return {
    line: getLineNumber(range),
    column: getColumnNumber(range),
    range: range
  };
}
```

### 2.3 题目渲染方案

#### 2.3.1 题目元素标识
```typescript
// 在Markdown中使用特殊语法标识题目
const QUESTION_SYNTAX = /^@question\{([^}]+)\}(.*?)(?=^@question\{|\n\n|$)/gms;

// 示例：
// @question{question-id-123}
// 这是一道数学题...
// 选项A: ...
// 选项B: ...
// @end
```

#### 2.3.2 题目渲染器
```typescript
class QuestionRenderer {
  // 将题目语法渲染为HTML
  renderQuestion(match: string, questionId: string, content: string): string {
    return `
      <div class="question-element" data-question-id="${questionId}">
        <div class="question-header">
          <span class="question-icon">📝</span>
          <span class="question-title">题目 ${questionId}</span>
          <button class="question-edit-btn">编辑</button>
          <button class="question-delete-btn">删除</button>
        </div>
        <div class="question-content">
          ${this.renderQuestionContent(content)}
        </div>
      </div>
    `;
  }
  
  // 渲染题目内容（支持LaTeX、图片等）
  private renderQuestionContent(content: string): string {
    // 1. 解析LaTeX公式
    content = this.renderLatex(content);
    
    // 2. 解析图片
    content = this.renderImages(content);
    
    // 3. 解析其他Markdown语法
    content = this.renderMarkdown(content);
    
    return content;
  }
}
```

### 2.4 题目编辑功能

#### 2.4.1 编辑模式切换
```typescript
class QuestionEditor {
  // 进入题目编辑模式
  enterEditMode(questionElement: HTMLElement): void {
    // 1. 保存原始内容
    const originalContent = questionElement.dataset.originalContent;
    
    // 2. 切换到编辑模式
    questionElement.classList.add('editing');
    questionElement.contentEditable = 'true';
    
    // 3. 显示编辑工具栏
    this.showEditToolbar(questionElement);
    
    // 4. 聚焦到编辑区域
    questionElement.focus();
  }
  
  // 退出编辑模式
  exitEditMode(questionElement: HTMLElement): void {
    // 1. 保存编辑内容
    const editedContent = questionElement.textContent;
    
    // 2. 重新渲染题目
    this.rerenderQuestion(questionElement, editedContent);
    
    // 3. 退出编辑模式
    questionElement.classList.remove('editing');
    questionElement.contentEditable = 'false';
    
    // 4. 隐藏编辑工具栏
    this.hideEditToolbar(questionElement);
  }
}
```

#### 2.4.2 题目内容同步
```typescript
// 题目内容变更时的处理
function handleQuestionContentChange(questionElement: HTMLElement): void {
  const questionId = questionElement.dataset.questionId;
  const newContent = questionElement.textContent;
  
  // 1. 更新题目数据
  updateQuestionData(questionId, newContent);
  
  // 2. 触发编辑器内容变更
  triggerEditorChange();
  
  // 3. 重新渲染题目（如果需要）
  if (shouldRerender(questionElement)) {
    rerenderQuestion(questionElement);
  }
}
```

## 3. 与即时渲染编辑器的集成

### 3.1 题目语法解析
```typescript
// 在Markdown解析器中添加题目语法支持
class MarkdownParser {
  parse(content: string): string {
    let html = content;
    
    // 1. 解析题目语法
    html = this.parseQuestions(html);
    
    // 2. 解析其他Markdown语法
    html = this.parseMarkdown(html);
    
    return html;
  }
  
  private parseQuestions(content: string): string {
    return content.replace(QUESTION_SYNTAX, (match, questionId, content) => {
      return this.questionRenderer.renderQuestion(match, questionId, content);
    });
  }
}
```

### 3.2 光标管理适配
```typescript
// 在光标管理中添加题目元素支持
class CursorManager {
  // 保存光标位置时考虑题目元素
  saveCursor(): CursorInfo {
    const selection = window.getSelection();
    const range = selection.getRangeAt(0);
    
    // 检查光标是否在题目元素内
    const questionElement = this.findQuestionElement(range.startContainer);
    
    if (questionElement) {
      return {
        type: 'question',
        questionId: questionElement.dataset.questionId,
        offset: this.getOffsetInQuestion(questionElement, range),
        isEditing: questionElement.classList.contains('editing')
      };
    }
    
    // 普通文本光标处理
    return this.saveTextCursor(range);
  }
  
  // 恢复光标位置时考虑题目元素
  restoreCursor(cursorInfo: CursorInfo): void {
    if (cursorInfo.type === 'question') {
      this.restoreQuestionCursor(cursorInfo);
    } else {
      this.restoreTextCursor(cursorInfo);
    }
  }
}
```

### 3.3 事件处理集成
```typescript
// 在编辑器事件处理中添加题目相关事件
class EditorEventHandler {
  setupEventListeners(): void {
    // 1. 基础编辑器事件
    this.editor.addEventListener('input', this.handleInput.bind(this));
    this.editor.addEventListener('keydown', this.handleKeydown.bind(this));
    
    // 2. 题目相关事件
    this.editor.addEventListener('click', this.handleQuestionClick.bind(this));
    this.editor.addEventListener('dragstart', this.handleDragStart.bind(this));
    this.editor.addEventListener('dragover', this.handleDragOver.bind(this));
    this.editor.addEventListener('drop', this.handleDrop.bind(this));
  }
  
  // 处理题目点击事件
  private handleQuestionClick(event: MouseEvent): void {
    const questionElement = this.findQuestionElement(event.target);
    if (questionElement) {
      this.handleQuestionInteraction(questionElement, event);
    }
  }
  
  // 处理拖拽开始
  private handleDragStart(event: DragEvent): void {
    const questionElement = this.findQuestionElement(event.target);
    if (questionElement) {
      event.dataTransfer.setData('text/plain', questionElement.dataset.questionId);
      event.dataTransfer.effectAllowed = 'move';
    }
  }
  
  // 处理拖拽放置
  private handleDrop(event: DragEvent): void {
    event.preventDefault();
    
    const questionId = event.dataTransfer.getData('text/plain');
    const position = this.calculateInsertPosition(event);
    
    this.insertQuestion(questionId, position);
  }
}
```

## 4. 用户界面设计

### 4.1 题目选择界面
```typescript
interface QuestionSelector {
  // 题目列表显示
  showQuestionList(questions: Question[]): void;
  
  // 题目搜索和筛选
  filterQuestions(criteria: FilterCriteria): Question[];
  
  // 拖拽预览
  showDragPreview(question: Question): void;
}
```

### 4.2 题目编辑界面
```typescript
interface QuestionEditInterface {
  // 编辑工具栏
  showEditToolbar(questionElement: HTMLElement): void;
  
  // 题目属性编辑
  editQuestionProperties(questionId: string): void;
  
  // 题目内容编辑
  editQuestionContent(questionId: string): void;
}
```

### 4.3 题目状态指示
```typescript
// 题目状态可视化
enum QuestionStatus {
  NORMAL = 'normal',           // 正常状态
  EDITING = 'editing',         // 编辑中
  MODIFIED = 'modified',       // 已修改
  ERROR = 'error',            // 错误状态
  LOADING = 'loading'         // 加载中
}

// 状态样式
const statusStyles = {
  [QuestionStatus.NORMAL]: 'question-normal',
  [QuestionStatus.EDITING]: 'question-editing',
  [QuestionStatus.MODIFIED]: 'question-modified',
  [QuestionStatus.ERROR]: 'question-error',
  [QuestionStatus.LOADING]: 'question-loading'
};
```

## 5. 数据管理

### 5.1 题目数据同步
```typescript
class QuestionDataManager {
  // 题目数据缓存
  private questionCache: Map<string, Question> = new Map();
  
  // 获取题目数据
  async getQuestion(questionId: string): Promise<Question> {
    if (this.questionCache.has(questionId)) {
      return this.questionCache.get(questionId);
    }
    
    const question = await this.fetchQuestion(questionId);
    this.questionCache.set(questionId, question);
    return question;
  }
  
  // 更新题目数据
  async updateQuestion(questionId: string, content: string): Promise<void> {
    const question = this.questionCache.get(questionId);
    if (question) {
      question.content = content;
      question.modifiedAt = new Date();
      
      // 同步到服务器
      await this.syncQuestion(question);
    }
  }
}
```

### 5.2 题目引用管理
```typescript
class QuestionReferenceManager {
  // 题目引用关系
  private references: Map<string, string[]> = new Map();
  
  // 添加题目引用
  addReference(lectureId: string, questionId: string): void {
    if (!this.references.has(lectureId)) {
      this.references.set(lectureId, []);
    }
    
    const refs = this.references.get(lectureId);
    if (!refs.includes(questionId)) {
      refs.push(questionId);
    }
  }
  
  // 移除题目引用
  removeReference(lectureId: string, questionId: string): void {
    const refs = this.references.get(lectureId);
    if (refs) {
      const index = refs.indexOf(questionId);
      if (index > -1) {
        refs.splice(index, 1);
      }
    }
  }
}
```

## 6. 性能优化

### 6.1 题目渲染优化
```typescript
// 题目渲染优化策略
class QuestionRenderOptimizer {
  // 懒加载题目内容
  lazyLoadQuestion(questionElement: HTMLElement): void {
    const questionId = questionElement.dataset.questionId;
    
    // 显示占位符
    questionElement.innerHTML = this.createPlaceholder();
    
    // 异步加载题目内容
    this.loadQuestionContent(questionId).then(content => {
      questionElement.innerHTML = content;
    });
  }
  
  // 虚拟滚动（大量题目时）
  virtualScroll(container: HTMLElement): void {
    // 只渲染可见区域的题目
    const visibleRange = this.calculateVisibleRange(container);
    this.renderVisibleQuestions(visibleRange);
  }
}
```

### 6.2 事件处理优化
```typescript
// 事件处理优化
class EventOptimizer {
  // 事件委托
  setupEventDelegation(): void {
    this.editor.addEventListener('click', (event) => {
      const target = event.target as HTMLElement;
      
      if (target.classList.contains('question-edit-btn')) {
        this.handleEditClick(target);
      } else if (target.classList.contains('question-delete-btn')) {
        this.handleDeleteClick(target);
      }
    });
  }
  
  // 防抖处理
  debounceQuestionUpdate(questionId: string, content: string): void {
    clearTimeout(this.updateTimers.get(questionId));
    this.updateTimers.set(questionId, setTimeout(() => {
      this.updateQuestion(questionId, content);
    }, 500));
  }
}
```

## 7. 错误处理

### 7.1 题目加载错误
```typescript
class QuestionErrorHandler {
  // 题目加载失败处理
  handleLoadError(questionId: string, error: Error): void {
    console.error(`Failed to load question ${questionId}:`, error);
    
    // 显示错误占位符
    this.showErrorPlaceholder(questionId, error.message);
    
    // 提供重试选项
    this.showRetryOption(questionId);
  }
  
  // 题目渲染错误处理
  handleRenderError(questionElement: HTMLElement, error: Error): void {
    questionElement.classList.add('error');
    questionElement.innerHTML = `
      <div class="question-error">
        <span class="error-icon">⚠️</span>
        <span class="error-message">题目渲染失败</span>
        <button class="retry-btn">重试</button>
      </div>
    `;
  }
}
```

## 8. 总结

题目插入功能的实现需要：

1. **数据结构设计**：清晰的题目元素数据结构
2. **拖拽机制**：完整的拖拽插入流程
3. **渲染系统**：题目语法的解析和渲染
4. **编辑功能**：题目的内联编辑能力
5. **光标管理**：与即时渲染编辑器的光标管理集成
6. **事件处理**：题目相关事件的统一处理
7. **数据同步**：题目数据的缓存和同步
8. **性能优化**：懒加载、虚拟滚动等优化策略
9. **错误处理**：完善的错误处理和恢复机制

这个设计可以完美集成到即时渲染编辑器中，提供流畅的题目插入和编辑体验。
